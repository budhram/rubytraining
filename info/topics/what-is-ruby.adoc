= Topic Name
:toc: macro
:toclevels: 2
:next-topic: Proceed to link:history-of-ruby.adoc#[History of Ruby]
:topic-table: Go to link:../../README.adoc#[Table of Content]

toc::[]

=== Overview

Ruby is an interpreted, high-level, general-purpose programming language. 
It was designed and developed in the mid-1990s by Yukihiro "Matz" Matsumoto in Japan.

Ruby is dynamically typed and garbage-collected. 
It supports multiple programming paradigms, including procedural, object-oriented, and functional programming.

Let's see above in details:

- Interpreted

An interpreted language is a type of programming language for which most of its implementations execute instructions directly and freely, without previously compiling a program into machine-language instructions. 
The interpreter executes the program directly, translating each statement into a sequence of one or more subroutines, and then into another language (often machine code)

- High Level

High-level language refers to the higher level of abstraction from machine language. 
Rather than dealing with registers, memory addresses and call stacks, high-level languages deal with variables, arrays, objects, complex arithmetic or boolean expressions, subroutines and functions, loops, threads, locks, and other abstract computer science concepts, with a focus on usability over optimal program efficiency.

- General Purpose

Designed to be used for writing software in the widest variety of application domains.
Conversely, a domain-specific programming language is one designed to be used within a specific application domain.

- Dynamically Typed

The type is associated with run-time values, and not named variables/fields etc. This means that a programmer can write a need not have to specify types every time.
Conversely, type of a variable is known at compile time for a Statically Typed.

=== Philosophy of Ruby

In an interview Matz discuss about the _Philosophy of Ruby_ where he described about why he designed Ruby.
link:https://www.artima.com/intv/ruby.html[Click here for full interview.]


- No Perfect Language

Instead of emphasizing the what, I want to emphasize the how part: how we feel while programming. That's Ruby's main difference from other language designs. I emphasize the feeling, in particular, how I feel using Ruby. I didn't work hard to make Ruby perfect for everyone, because you feel differently from me. No language can be perfect for everyone. I tried to make Ruby perfect for me, but maybe it's not perfect for you.

- Freedom and Comfort

Ruby inherited the Perl philosophy of having more than one way to do the same thing. I want to make Ruby users free. I want to give them the freedom to choose. People are different. People choose different criteria. But if there is a better way among many alternatives, I want to encourage that way by making it comfortable.

- The Joy of Ruby

You want to enjoy life, don't you? If you get your job done quickly and your job is fun, that's good isn't it? That's the purpose of life, partly. Your life is better.
I want to solve problems I meet in the daily life by using computers, so I need to write programs.

- The Human Factor

Often people, especially computer engineers, focus on the machines. They think, "By doing this, the machine will run faster. By doing this, the machine will run more effectively. By doing this, the machine will something something something." They are focusing on machines. But in fact we need to focus on humans, on how humans care about doing programming or operating the application of the machines. We are the masters. They are the slaves.

- Principle of Least Surprise

The principle of least surprise means principle of least my surprise. And it means the principle of least surprise after you learn Ruby very well. For example, I was a C++ programmer before I started designing Ruby. I programmed in C++ exclusively for two or three years. And after two years of C++ programming, it still surprised me.

=== Next Topic

{next-topic}

=== Table of Content

{topic-table}
